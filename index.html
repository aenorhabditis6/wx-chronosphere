<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WX åˆ›ä¸–çºªÂ·ç§¯åˆ†ä»ª</title>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Font for coolness -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #05070a; 
            --accent-gold: #ffd700; /* WX */
            --accent-red: #ff3333; /* MJS/Blood */
            --accent-cyan: #00f3ff; /* Science/High Tech */
            --accent-purple: #bd00ff; /* Mystery */
            --glass-panel: rgba(10, 15, 30, 0.6);
            --border-color: rgba(255, 215, 0, 0.3);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: #eeeeee;
            font-family: 'Noto Serif SC', serif;
            user-select: none;
        }

        /* The Container for Three.js */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .hud-panel {
            position: absolute;
            padding: 25px;
            pointer-events: auto;
            background: linear-gradient(135deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(5px);
        }

        .top-left { 
            top: 20px; left: 20px; 
            border-right: none; border-bottom: none; border-top: 2px solid var(--accent-gold); border-left: 2px solid var(--accent-gold);
            clip-path: polygon(0 0, 100% 0, 100% 85%, 85% 100%, 0 100%);
        }
        
        .top-right { 
            top: 20px; right: 20px; 
            text-align: right; 
            border: none;
            background: none;
        }

        h1 {
            color: var(--accent-gold);
            margin: 0;
            font-size: 2rem;
            letter-spacing: 5px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            font-weight: 700;
        }

        .subtitle {
            font-size: 0.9rem;
            color: var(--accent-cyan);
            margin-bottom: 15px;
            opacity: 1;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px var(--accent-cyan);
        }

        /* Magical Buttons */
        .btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Noto Serif SC', serif;
            font-weight: bold;
            transition: all 0.4s ease;
            margin-top: 5px;
            pointer-events: auto;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent);
            transition: 0.5s;
        }

        .btn:hover::before { left: 100%; }
        .btn:hover {
            background: var(--accent-gold);
            color: #000;
            box-shadow: 0 0 20px var(--accent-gold);
        }

        .btn-ai { border-color: var(--accent-red); color: var(--accent-red); }
        .btn-ai:hover { background: var(--accent-red); color: #000; box-shadow: 0 0 20px var(--accent-red); }

        .btn-export { border-color: var(--accent-cyan); color: var(--accent-cyan); font-size: 0.75rem; padding: 5px 10px; margin-top: 15px;}
        .btn-export:hover { background: var(--accent-cyan); color: #000; box-shadow: 0 0 10px var(--accent-cyan); }

        /* Orbit Labels */
        .orbit-label {
            position: absolute;
            color: rgba(255, 255, 255, 0.5); 
            font-size: 1.0rem; 
            font-weight: 300; 
            pointer-events: none;
            text-align: center;
            width: 300px;
            margin-left: -150px;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.3); 
            letter-spacing: 3px;
            font-family: 'Noto Serif SC', serif;
            transition: opacity 0.3s;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(10, 15, 25, 0.95);
            border: 1px solid var(--accent-cyan);
            padding: 20px;
            display: none;
            pointer-events: none;
            max-width: 300px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.3);
            z-index: 1000;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        
        #tooltip h3 { margin: 0 0 5px 0; color: var(--accent-gold); font-size: 1.2rem; border-bottom: 1px solid #555; padding-bottom: 5px; text-shadow: 0 0 5px var(--accent-gold);}
        #tooltip p { margin: 5px 0; font-size: 0.95rem; line-height: 1.6; color: #fff; }
        .subtasks-list { color: #aaa; font-size: 0.85rem; margin-top: 10px; padding-top: 5px; border-top: 1px dashed #666; }
        .tooltip-hint { font-size: 0.7rem; color: var(--accent-red); margin-top: 8px; font-style: italic; text-align: right; }

        /* Modal */
        #modal, #export-modal {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 18, 24, 0.98);
            border: 1px solid var(--accent-gold);
            padding: 40px;
            z-index: 100;
            display: none;
            box-shadow: 0 0 100px rgba(0,0,0,0.9);
            pointer-events: auto;
            width: 400px;
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
        }

        #modal h3, #export-modal h3 { color: var(--accent-gold); margin-top: 0; text-align: center; letter-spacing: 3px; border-bottom: 1px solid #333; padding-bottom: 15px;}
        #modal input, #modal textarea, #export-code {
            width: 100%;
            background: rgba(255,255,255,0.1); 
            border: 1px solid #666;
            color: white;
            padding: 12px;
            margin-top: 8px;
            font-family: inherit;
            box-sizing: border-box;
            transition: 0.3s;
        }
        #modal input:focus, #modal textarea:focus { border-color: var(--accent-gold); outline: none; background: rgba(255,255,255,0.15); }
        
        .ai-section {
            border: 1px dashed var(--accent-red);
            padding: 15px;
            margin-bottom: 20px;
            background: rgba(255, 50, 50, 0.1);
        }

        .modal-btns { display: flex; justify-content: space-between; margin-top: 30px; }

        .loading { opacity: 0.7; cursor: wait; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
</head>
<body>

    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- HTML UI Overlay -->
    <div id="ui-layer">
        <div class="hud-panel top-left">
            <h1>ç§¯åˆ†åˆ›ä¸–çºª</h1>
            <div class="subtitle">System: WX-Integral-Engine // Ver 8.0 [Persistence]</div>
            <div class="subtitle" id="current-wx-date">çºªå…ƒ: æ”¶æ•›çºª 5å¹´</div>
            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                <button class="btn" onclick="openModal()">+ é“­åˆ»å¾‹æ³•</button>
                <button class="btn btn-ai" id="scan-btn" onclick="deepSpaceScan()">ğŸ‘ è§‚æµ‹å¤©å¹•</button>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-export" onclick="exportData()">ğŸ“¤ å¯¼å‡ºä¸–ç•Œçº¿</button>
                <button class="btn btn-export" onclick="resetData()" style="color:#ff4444; border-color:#ff4444;">ğŸ”„ é‡ç½®</button>
            </div>
            <div style="margin-top: 15px; font-size: 0.75rem; color: #aaa; font-family: monospace;">
                [å·¦é”®] æ—‹è½¬/ç‚¹å‡»è¡Œæ˜Ÿ â€¢ [æ»šè½®] ç¼©æ”¾ â€¢ [æ‚¬åœ] å†»ç»“
            </div>
        </div>

        <div class="hud-panel top-right">
            <div style="color: var(--accent-gold); letter-spacing: 2px; font-weight: bold;">å½“å‰è§‚æµ‹åŸŸ</div>
            <div style="font-size: 3rem; color: white; text-shadow: 0 0 25px var(--accent-cyan); font-family: monospace;" id="clock-display">00:00</div>
            <div style="color: #aaa; font-size: 0.8rem;">æ”¶æ•›ä¸­...</div>
        </div>

        <!-- Floating Labels -->
        <div id="label-proximal" class="orbit-label">ç¬¬ä¸€æƒæŸ„Â·çº¿<br><span style="font-size:0.7rem; color: var(--accent-cyan); opacity: 0.7;">å› æœ / å¤©æ–‡</span></div>
        <div id="label-distal" class="orbit-label">ç¬¬äºŒæƒæŸ„Â·é¢<br><span style="font-size:0.7rem; color: var(--accent-cyan); opacity: 0.7;">ç»´åº¦ / ç©ºé—´</span></div>
        <div id="label-outer" class="orbit-label">ç¬¬ä¸‰æƒæŸ„Â·ä½“<br><span style="font-size:0.7rem; color: var(--accent-cyan); opacity: 0.7;">ç”Ÿå‘½ / ç‰©è´¨</span></div>

        <!-- Tooltip -->
        <div id="tooltip">
            <h3 id="tt-title">Event Name</h3>
            <p id="tt-date">Date</p>
            <p id="tt-desc">Description</p>
            <div id="tt-subtasks" class="subtasks-list"></div>
            <div class="tooltip-hint">ç‚¹å‡»ä»¥æŠ¹é™¤æ­¤å› æœ</div>
        </div>
    </div>

    <!-- Modal Form -->
    <div id="modal">
        <h3>é“­åˆ»æ–°å¾‹æ³•</h3>
        <div class="ai-section">
            <label style="color: var(--accent-red); margin-top:0; font-size: 0.9rem; font-weight: bold;">â—† ç¥è°•è§£æ (AI)</label>
            <textarea id="ai-input" rows="2" placeholder="ä¾‹å¦‚ï¼šä¸‹å‘¨äº”å»åå¾®é˜å’Œè·¯å°å§å–èŒ¶..."></textarea>
            <button class="btn btn-ai" id="magic-btn" onclick="magicFill()" style="width: 100%; margin-top: 10px; font-size: 0.9rem;">âœ¨ è§£æç¥è°•</button>
        </div>
        
        <label style="font-size: 0.9rem; color: #aaa;">å¾‹æ³•åç§°</label> 
        <input type="text" id="input-title">
        
        <label style="font-size: 0.9rem; color: #aaa;">è·ç¦» (å¤©æ•°)</label> 
        <input type="number" id="input-days" value="1">
        
        <label style="font-size: 0.9rem; color: #aaa;">å¾‹æ³•æè¿°</label> 
        <textarea id="input-desc" rows="2"></textarea>
        
        <label style="font-size: 0.9rem; color: #aaa;">æ¬¡çº§åˆ†å½¢ (å­ä»»åŠ¡ï¼Œé€—å·åˆ†éš”)</label> 
        <input type="text" id="input-subtasks" placeholder="ä¾‹å¦‚ï¼šå‡†å¤‡ç¥­å“, ç»˜åˆ¶æ³•é˜µ">
        
        <div class="modal-btns">
            <button class="btn" onclick="saveEvent()">ç¡®è®¤é“­åˆ»</button>
            <button class="btn" onclick="closeModal()" style="border-color: #888; color: #888;">æ”¾å¼ƒ</button>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="export-modal">
        <h3>ä¸–ç•Œçº¿ä»£ç </h3>
        <p style="font-size:0.8rem; color:#aaa;">å¤åˆ¶ä¸‹æ–¹ä»£ç ï¼Œè¦†ç›– GitHub ä¸­ index.html çš„ wxEvents æ•°ç»„ï¼Œå³å¯å°†å½“å‰å˜åŠ¨å›ºåŒ–ä¸ºæ°¸æ’çœŸç†ã€‚</p>
        <textarea id="export-code" rows="10" readonly></textarea>
        <div class="modal-btns">
            <button class="btn" onclick="document.getElementById('export-modal').style.display='none'">å…³é—­</button>
        </div>
    </div>

    <script>
        /** * DATA CORE: WX UNIVERSE & STORAGE */
        
        // Default Genesis Events
        const defaultEvents = [
            { title: "å°ç†Šçš„è¯è¾°", daysAway: 2, desc: "ç†Šæ‰‹å…šå°†åœ¨å¤§å…ä¸¾åŠç››å®´ã€‚", color: "#ff4444", subtasks: ["é¢„å®šèœ‚èœœè›‹ç³•", "è—å¥½ç¤¼ç‰©"] },
            { title: "å»ºè®¾å†›æ¼”ä¹ ", daysAway: 14, desc: "é˜¿é˜³å¸¦é¢†çš„æœˆåº¦å†›äº‹æ¼”ç»ƒã€‚", color: "#44ff44", subtasks: ["æ£€ä¿®è£…å¤‡"] },
            { title: "æ»¡æœˆç¥­", daysAway: 28, desc: "å¤©å¹•ä¸­å‡½æ•°æœ€è¿ç»­çš„æ—¶åˆ»ã€‚", color: "#ffff44" },
            { title: "æ‹“æ‰‘å­¦è®²åº§", daysAway: 5, desc: "èƒ–èƒ–åšå£«å…³äºæµå½¢çš„æ¼”è®²ã€‚", color: "#00f3ff", subtasks: ["å‡†å¤‡è®²ä¹‰", "æ“¦ç™½æ¿"] },
            { title: "ä»£æ•°å‡ ä½•ç ”è®¨", daysAway: 60, desc: "MJS ä¸»æŒçš„é—­é—¨ä¼šè®®ã€‚", color: "#bd00ff" }
        ];

        // Load from LocalStorage or use Default
        let wxEvents = [];
        const savedData = localStorage.getItem('wx_universe_events');
        if(savedData) {
            try {
                wxEvents = JSON.parse(savedData);
            } catch(e) {
                console.error("Save file corrupted, reverting to genesis.", e);
                wxEvents = [...defaultEvents];
            }
        } else {
            wxEvents = [...defaultEvents];
        }

        // Helper to Save
        function persistData() {
            localStorage.setItem('wx_universe_events', JSON.stringify(wxEvents));
        }

        function resetData() {
            if(confirm("ã€è­¦å‘Šã€‘\næ‚¨ç¡®å®šè¦é‡ç½®ä¸–ç•Œçº¿å—ï¼Ÿ\næ‰€æœ‰æœªå›ºåŒ–çš„æœ¬åœ°å› æœå°†è¢«æŠ¹é™¤ã€‚")) {
                localStorage.removeItem('wx_universe_events');
                location.reload();
            }
        }

        function exportData() {
            const json = JSON.stringify(wxEvents, null, 4);
            const code = `let wxEvents = ${json};`;
            document.getElementById('export-code').value = code;
            document.getElementById('export-modal').style.display = 'block';
        }

        /** THREE.JS SETUP */
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x05070a, 0.01);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 80);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 3);
        scene.add(ambientLight);
        
        const sunLight = new THREE.PointLight(0xffd700, 3, 300); 
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);
        
        const rimLight = new THREE.DirectionalLight(0x00f3ff, 1);
        rimLight.position.set(50, 20, 50);
        scene.add(rimLight);

        const fillLight = new THREE.DirectionalLight(0xff3333, 0.5);
        fillLight.position.set(-50, 0, -50);
        scene.add(fillLight);

        /** OBJECTS */
        const groupPlanets = new THREE.Group();
        scene.add(groupPlanets);
        const groupOrbits = new THREE.Group();
        scene.add(groupOrbits);
        const groupEffects = new THREE.Group(); 
        scene.add(groupEffects);

        // 1. Central Singularity (WX's Core)
        const geoCore = new THREE.IcosahedronGeometry(3, 1);
        const matCore = new THREE.MeshStandardMaterial({ 
            color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 1, wireframe: true
        });
        const coreMesh = new THREE.Mesh(geoCore, matCore);
        scene.add(coreMesh);

        const geoInner = new THREE.SphereGeometry(2, 32, 32);
        const matInner = new THREE.MeshBasicMaterial({ color: 0xffffaa });
        const coreInner = new THREE.Mesh(geoInner, matInner);
        scene.add(coreInner);

        const spriteMaterialGlow = new THREE.SpriteMaterial({ 
            map: createGlowTexture(), 
            color: 0xffaa00, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending 
        });
        const spriteGlow = new THREE.Sprite(spriteMaterialGlow);
        spriteGlow.scale.set(30, 30, 1);
        scene.add(spriteGlow);

        // 2. The Inverted Tower
        const towerGeo = new THREE.ConeGeometry(20, 100, 4, 1, true); 
        const towerMat = new THREE.MeshBasicMaterial({ 
            color: 0x550000, wireframe: true, transparent: true, opacity: 0.2
        });
        const tower = new THREE.Mesh(towerGeo, towerMat);
        tower.rotation.x = Math.PI; 
        tower.position.y = -40; 
        scene.add(tower);

        // 3. Starfield with Mass Effect (Higgs Field)
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const posArray = new Float32Array(starsCount * 3);
        const initialPosArray = new Float32Array(starsCount * 3); 

        for(let i = 0; i < starsCount * 3; i++) { 
            const val = (Math.random() - 0.5) * 500;
            posArray[i] = val; 
            initialPosArray[i] = val; 
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        starsGeometry.setAttribute('initialPosition', new THREE.BufferAttribute(initialPosArray, 3));

        const starsMaterial = new THREE.PointsMaterial({ size: 0.9, color: 0xffffff, transparent: true, opacity: 0.9 });
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);

        // 3.5. Deep Void Background
        const bgStarsCount = 1500;
        const bgGeo = new THREE.BufferGeometry();
        const bgPos = new Float32Array(bgStarsCount * 3);
        for(let i = 0; i < bgStarsCount * 3; i+=3) {
            bgPos[i] = (Math.random() - 0.5) * 1200;
            bgPos[i+1] = (Math.random() - 0.5) * 1200;
            bgPos[i+2] = (Math.random() - 0.5) * 1200;
        }
        bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
        const bgMat = new THREE.PointsMaterial({ color: 0x8888aa, size: 0.6, transparent: true, opacity: 0.4 });
        const bgStarField = new THREE.Points(bgGeo, bgMat);
        scene.add(bgStarField);

        // 4. Brownian Motion Particles
        const brownianGeo = new THREE.BufferGeometry();
        const brownianCount = 100;
        const bPos = new Float32Array(brownianCount * 3);
        const bVel = []; 
        for(let i=0; i<brownianCount; i++){
            bPos[i*3] = (Math.random() - 0.5) * 20;
            bPos[i*3+1] = (Math.random() - 0.5) * 20;
            bPos[i*3+2] = (Math.random() - 0.5) * 20;
            bVel.push(new THREE.Vector3((Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1));
        }
        brownianGeo.setAttribute('position', new THREE.BufferAttribute(bPos, 3));
        const brownianMat = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.6, transparent: true, opacity: 0.8 });
        const brownianParticles = new THREE.Points(brownianGeo, brownianMat);
        scene.add(brownianParticles);

        // 5. Orbit Rings
        createIntegralRing(20, 0x00f3ff, 0.4); 
        createIntegralRing(40, 0x00f3ff, 0.3); 
        createIntegralRing(60, 0x00f3ff, 0.2); 

        // 6. Accretion Disk
        const accretionCount = 300;
        const accGeo = new THREE.BufferGeometry();
        const accPos = new Float32Array(accretionCount * 3);
        const accVel = []; 
        for(let i=0; i<accretionCount; i++) {
            let angle = Math.random() * Math.PI * 2;
            let radius = 5 + Math.random() * 25; 
            let y = (Math.random() - 0.5) * 2; 
            accPos[i*3] = Math.cos(angle) * radius;
            accPos[i*3+1] = y;
            accPos[i*3+2] = Math.sin(angle) * radius;
            accVel.push({ angle: angle, radius: radius, y: y, speed: 0.02 + Math.random() * 0.02 });
        }
        accGeo.setAttribute('position', new THREE.BufferAttribute(accPos, 3));
        const accMat = new THREE.PointsMaterial({ 
            color: 0xffaa00, size: 0.4, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending 
        });
        const accretionSystem = new THREE.Points(accGeo, accMat);
        groupEffects.add(accretionSystem);

        // 7. Floating Math Runes
        const runeCount = 20;
        const runesGroup = new THREE.Group();
        const symbols = ['âˆ«', 'âˆ‚', 'âˆ‘', 'âˆ', 'âˆ‡', 'âˆ…'];
        for(let i=0; i<runeCount; i++) {
            const sym = symbols[Math.floor(Math.random() * symbols.length)];
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: createTextTexture(sym),
                color: 0x00f3ff, transparent: true, opacity: 0.3 + Math.random() * 0.4, blending: THREE.AdditiveBlending
            }));
            sprite.position.set((Math.random()-0.5) * 100, (Math.random()-0.5) * 50, (Math.random()-0.5) * 100);
            sprite.scale.set(4, 4, 1);
            sprite.userData = { ySpd: (Math.random() - 0.5) * 0.05, rotSpd: (Math.random() - 0.5) * 0.01 };
            runesGroup.add(sprite);
        }
        groupEffects.add(runesGroup);


        function createIntegralRing(radius, color, opacity) {
            const geometry = new THREE.RingGeometry(radius - 0.2, radius + 0.2, 64);
            const material = new THREE.MeshBasicMaterial({ 
                color: color, transparent: true, opacity: opacity, side: THREE.DoubleSide, blending: THREE.AdditiveBlending
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.rotation.x = Math.PI / 2;
            groupOrbits.add(ring);
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,215,0,1)');
            grad.addColorStop(0.4, 'rgba(255,100,0,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 48px "Times New Roman", serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        /** LOGIC: PLANETS & MOONS */
        const planetMeshes = [];

        function refreshPlanets() {
            while(groupPlanets.children.length > 0){ groupPlanets.remove(groupPlanets.children[0]); }
            planetMeshes.length = 0;

            wxEvents.forEach((evt, index) => {
                let r = 10 + (evt.daysAway * 0.8);
                if (r > 70) r = 70;
                const angle = (index / wxEvents.length) * Math.PI * 2;
                const speed = 0.5 / Math.pow(r, 1.5); 

                const geometry = new THREE.SphereGeometry(0.8, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: evt.color || 0xffffff,
                    roughness: 0.2, metalness: 0.6,
                    emissive: evt.color, emissiveIntensity: 0.6 
                });
                const planet = new THREE.Mesh(geometry, material);
                planet.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
                
                const trailGeo = new THREE.BufferGeometry();
                const trailLen = 50; 
                const trailPos = new Float32Array(trailLen * 3);
                for(let i=0; i<trailLen; i++) {
                    trailPos[i*3] = planet.position.x;
                    trailPos[i*3+1] = planet.position.y;
                    trailPos[i*3+2] = planet.position.z;
                }
                trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
                const trailMat = new THREE.LineBasicMaterial({ 
                    color: evt.color, transparent: true, opacity: 0.4 
                });
                const trail = new THREE.Line(trailGeo, trailMat);
                groupEffects.add(trail);

                planet.userData = { 
                    ...evt, 
                    radius: r, 
                    angle: angle, 
                    speed: speed, 
                    moons: [], 
                    trail: trail, 
                    trailPositions: trailPos,
                    originalRef: evt
                };

                const lineGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -5, 0) 
                ]);
                const lineMat = new THREE.LineBasicMaterial({ color: evt.color, transparent: true, opacity: 0.5 });
                const line = new THREE.Line(lineGeo, lineMat);
                planet.add(line);

                if (evt.subtasks && evt.subtasks.length > 0) {
                    const limit = Math.min(evt.subtasks.length, 3);
                    for(let i=0; i<limit; i++) {
                        const moonGeo = new THREE.TetrahedronGeometry(0.25); 
                        const moonMat = new THREE.MeshStandardMaterial({ 
                            color: evt.color, emissive: evt.color, emissiveIntensity: 0.5
                        });
                        const moon = new THREE.Mesh(moonGeo, moonMat);
                        const dist = 1.5 + (i * 0.7);
                        const mAngle = Math.random() * Math.PI * 2;
                        const mSpeed = 0.05 + (i * 0.02);
                        moon.userData = { dist: dist, angle: mAngle, speed: mSpeed };
                        moon.position.set(Math.cos(mAngle)*dist, 0, Math.sin(mAngle)*dist);
                        planet.add(moon);
                        planet.userData.moons.push(moon);
                    }
                }
                groupPlanets.add(planet);
                planetMeshes.push(planet);
            });
        }
        refreshPlanets();

        /** INPUT & INTERACTION */
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        let theta = 0, phi = 60;
        let zoomRadius = 80;
        
        const raycaster = new THREE.Raycaster();
        const mouseVec = new THREE.Vector2();
        let mouseX=0, mouseY=0;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            prevMouse = { x: e.offsetX, y: e.offsetY }; 
        });
        
        document.addEventListener('mouseup', () => isDragging = false);
        
        // CLICK TO DELETE LOGIC
        renderer.domElement.addEventListener('click', (e) => {
            const dist = Math.hypot(e.offsetX - prevMouse.x, e.offsetY - prevMouse.y);
            if(dist > 5) return; 

            raycaster.setFromCamera(mouseVec, camera);
            const intersects = raycaster.intersectObjects(planetMeshes);
            
            if(intersects.length > 0) {
                const hit = intersects[0].object;
                const data = hit.userData;
                
                const confirmMsg = `ã€å¤©é“å®¡åˆ¤ã€‘\n\næ‚¨ç¡®å®šè¦æŠ¹é™¤è¿™æ¡å› æœå—ï¼Ÿ\n\n>> ${data.title}`;
                if(confirm(confirmMsg)) {
                    // Update main array
                    const index = wxEvents.indexOf(data.originalRef);
                    if(index > -1) {
                        groupEffects.remove(data.trail);
                        wxEvents.splice(index, 1);
                        persistData(); // SAVE TO LOCAL STORAGE
                        refreshPlanets();
                    }
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX; mouseY = e.clientY;
            if(isDragging) {
                theta -= (e.offsetX - prevMouse.x) * 0.005;
                phi -= (e.offsetY - prevMouse.y) * 0.2;
                phi = Math.max(10, Math.min(100, phi));
                prevMouse = { x: e.offsetX, y: e.offsetY };
            }
            mouseVec.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouseVec.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        
        document.addEventListener('wheel', (e) => {
            zoomRadius += e.deltaY * 0.05;
            zoomRadius = Math.max(20, Math.min(150, zoomRadius));
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // HIGGS FIELD CALCULATION
        const _tempV = new THREE.Vector3();
        const _targetV = new THREE.Vector3();

        /** ANIMATION LOOP */
        function animate() {
            requestAnimationFrame(animate);

            // Camera
            const rPhi = THREE.MathUtils.degToRad(phi);
            camera.position.x = zoomRadius * Math.sin(rPhi) * Math.sin(theta);
            camera.position.y = zoomRadius * Math.cos(rPhi);
            camera.position.z = zoomRadius * Math.sin(rPhi) * Math.cos(theta);
            camera.lookAt(0, 0, 0);

            const time = Date.now() * 0.002;
            coreMesh.rotation.y += 0.01;
            coreMesh.rotation.z += 0.005;
            spriteGlow.scale.setScalar(20 + Math.sin(time)*2);

            // Accretion
            const accPos = accretionSystem.geometry.attributes.position.array;
            for(let i=0; i<accretionCount; i++) {
                const particle = accVel[i];
                particle.angle += particle.speed * 0.5; 
                particle.radius -= 0.05; 
                if(particle.radius < 2) particle.radius = 30; 
                accPos[i*3] = Math.cos(particle.angle) * particle.radius;
                accPos[i*3+1] = particle.y;
                accPos[i*3+2] = Math.sin(particle.angle) * particle.radius;
            }
            accretionSystem.geometry.attributes.position.needsUpdate = true;

            // Runes
            runesGroup.children.forEach(sprite => {
                sprite.position.y += sprite.userData.ySpd;
                if(sprite.position.y > 50 || sprite.position.y < -50) sprite.userData.ySpd *= -1;
            });

            // Brownian
            const posAttr = brownianGeo.attributes.position;
            for(let i=0; i<brownianCount; i++){
                let x = posAttr.getX(i) + bVel[i].x;
                let y = posAttr.getY(i) + bVel[i].y;
                let z = posAttr.getZ(i) + bVel[i].z;
                if(Math.abs(x) > 10) bVel[i].x *= -1;
                if(Math.abs(y) > 10) bVel[i].y *= -1;
                if(Math.abs(z) > 10) bVel[i].z *= -1;
                posAttr.setXYZ(i, x, y, z);
            }
            posAttr.needsUpdate = true;

            // Background Stars
            bgStarField.rotation.y += 0.00005;
            bgStarField.rotation.x -= 0.00002;
            bgMat.opacity = 0.4 + Math.sin(time) * 0.1;

            // HIGGS FIELD
            raycaster.setFromCamera(mouseVec, camera);
            const ray = raycaster.ray;
            const starPosAttr = starsGeometry.attributes.position;
            const starInitAttr = starsGeometry.attributes.initialPosition;

            for(let i=0; i < starsCount; i++) {
                const ix = starInitAttr.getX(i);
                const iy = starInitAttr.getY(i);
                const iz = starInitAttr.getZ(i);
                _tempV.set(ix, iy, iz);

                const cx = starPosAttr.getX(i);
                const cy = starPosAttr.getY(i);
                const cz = starPosAttr.getZ(i);

                const distSq = ray.distanceSqToPoint(_tempV);

                if(distSq < 1500) { 
                    ray.closestPointToPoint(_tempV, _targetV);
                    const tx = cx + (_targetV.x - cx) * 0.05;
                    const ty = cy + (_targetV.y - cy) * 0.05;
                    const tz = cz + (_targetV.z - cz) * 0.05;
                    starPosAttr.setXYZ(i, tx, ty, tz);
                } else {
                    const tx = cx + (ix - cx) * 0.02;
                    const ty = cy + (iy - cy) * 0.02;
                    const tz = cz + (iz - cz) * 0.02;
                    starPosAttr.setXYZ(i, tx, ty, tz);
                }
            }
            starPosAttr.needsUpdate = true;

            // Planet Logic
            const intersects = raycaster.intersectObjects(planetMeshes);
            const tooltip = document.getElementById('tooltip');
            const ttSub = document.getElementById('tt-subtasks');
            let frozenPlanet = null;

            if(intersects.length > 0) {
                const hit = intersects[0].object;
                const data = hit.userData;
                frozenPlanet = hit;
                tooltip.style.display = 'block';
                tooltip.style.left = (mouseX + 20) + 'px';
                tooltip.style.top = (mouseY + 20) + 'px';
                document.getElementById('tt-title').innerText = data.title;
                document.getElementById('tt-date').innerText = `é¢„è®¡æŠµè¾¾: ${data.daysAway} å¤©å`;
                document.getElementById('tt-desc').innerText = data.desc;
                if (data.subtasks && data.subtasks.length > 0) {
                    ttSub.style.display = 'block';
                    ttSub.innerHTML = '<strong>æ¬¡çº§åˆ†å½¢:</strong><br>' + data.subtasks.map(s => `â€¢ ${s}`).join('<br>');
                } else { ttSub.style.display = 'none'; }
                hit.scale.setScalar(1.5);
                document.body.style.cursor = "pointer";
            } else {
                tooltip.style.display = 'none';
                planetMeshes.forEach(p => p.scale.setScalar(1));
                document.body.style.cursor = "default";
            }

            planetMeshes.forEach(p => {
                if(p === frozenPlanet) return; 
                p.userData.angle += p.userData.speed;
                const newX = Math.cos(p.userData.angle) * p.userData.radius;
                const newZ = Math.sin(p.userData.angle) * p.userData.radius;
                p.position.set(newX, 0, newZ);
                p.rotation.y += 0.02;

                const positions = p.userData.trailPositions;
                for(let i = positions.length - 1; i >= 3; i--) {
                    positions[i] = positions[i-3];
                }
                positions[0] = newX;
                positions[1] = 0;
                positions[2] = newZ;
                p.userData.trail.geometry.attributes.position.needsUpdate = true;

                p.userData.moons.forEach(m => {
                    m.userData.angle += m.userData.speed;
                    m.position.x = Math.cos(m.userData.angle) * m.userData.dist;
                    m.position.z = Math.sin(m.userData.angle) * m.userData.dist;
                    m.rotation.x += 0.05; 
                });
            });

            starField.rotation.y -= 0.0001;
            tower.rotation.y += 0.0005;

            updateLabel(20, 'label-proximal');
            updateLabel(40, 'label-distal');
            updateLabel(60, 'label-outer');

            renderer.render(scene, camera);
        }

        function updateLabel(radius, id) {
            const vec = new THREE.Vector3(radius, 0, 0);
            vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            const el = document.getElementById(id);
            if(vec.z > 1 || Math.abs(vec.x) > 1 || Math.abs(vec.y) > 1) {
                el.style.opacity = 0;
            } else {
                el.style.opacity = 1;
                el.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                el.style.left = 0; el.style.top = 0; 
            }
        }

        animate();

        /** AI Logic */
        let apiKey = localStorage.getItem("wx_gemini_key") || ""; 

        async function callGemini(prompt) {
            if (!apiKey) {
                const inputKey = prompt("âš ï¸ è§‚æµ‹å¤©å¹•éœ€è¦å¯†é’¥\n\nè¯·è¾“å…¥ Google Gemini API Key ä»¥è¿æ¥ç¥è°•ï¼š\n(å¯†é’¥ä»…ä¿å­˜åœ¨æ‚¨çš„æµè§ˆå™¨æœ¬åœ°ï¼Œä¸ä¼šä¸Šä¼ )");
                if (inputKey) {
                    apiKey = inputKey.trim();
                    localStorage.setItem("wx_gemini_key", apiKey);
                } else {
                    alert("æœªæä¾›å¯†é’¥ï¼Œæ— æ³•è§£æç¥è°•ã€‚");
                    return null;
                }
            }

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                if (!response.ok) throw new Error("API è¯·æ±‚å¤±è´¥");
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text;
            } catch (e) { 
                console.error(e); 
                if(confirm("è¿æ¥å¤©å¹•å¤±è´¥ (å¯èƒ½æ˜¯ Key æ— æ•ˆ)ã€‚\næ˜¯å¦æ¸…é™¤æœ¬åœ° Key å¹¶é‡è¯•ï¼Ÿ")) {
                    localStorage.removeItem("wx_gemini_key");
                    apiKey = "";
                }
                return null; 
            }
        }

        async function deepSpaceScan() {
            const btn = document.getElementById('scan-btn');
            btn.classList.add('loading'); btn.innerText = "è§‚æµ‹æ”¶æ•›ä¸­...";
            const prompt = `
            åŸºäºä»¥ä¸‹ã€Šç§¯åˆ†åˆ›ä¸–çºªã€‹ä¸–ç•Œè§‚ï¼Œç”Ÿæˆ 3 ä¸ªæœ‰è¶£çš„æœªæ¥æ—¥ç¨‹/äº‹ä»¶ã€‚
            ä¸–ç•Œè§‚å…³é”®è¯ï¼š
            - WX (ç§¯åˆ†å¤ç¥ï¼Œå¥‡ç‚¹ï¼Œåˆ›é€ è€…)
            - MJS (ä»£æ•°å‡ ä½•å¤©ä½¿ï¼Œå€’æ‚¬é«˜å¡”ï¼Œåå›è€…ï¼Œçº¢è‰²)
            - å¸•æ‹‰ (Pneuma, åŒ»å­¦ä¹‹ç¥ï¼Œè®°å¿†ç¼åˆï¼Œç™½è‰²)
            - å‹‡è€… J (åé£Ÿè‹¦éš¾ï¼Œæ±‚è§£PDE)
            - å¤§B (å¤©æ–‡å­¦å®¶ï¼Œç¬¬ä¸€æƒæŸ„ï¼Œè§‚æµ‹è€…)
            - è‰¾è‰/å¸Œç ç‘ (CS, è™šæ„å¤©ä½¿, æ¸²æŸ“)
            è¯·ç”¨ä¸­æ–‡è¿”å›ä¸€ä¸ªåˆæ³•çš„ JSON æ•°ç»„ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
            [{"title":"äº‹ä»¶å", "daysAway":æ•´æ•°(1-60), "desc":"åŸºäºä¸–ç•Œè§‚çš„æè¿°", "color":"#hex", "subtasks": ["å­ä»»åŠ¡1", "å­ä»»åŠ¡2"]}]
            ç¡®ä¿å†…å®¹æœ‰äº›â€œä¸­äºŒâ€å’Œç¥ç§˜æ„Ÿã€‚
            `;
            const res = await callGemini(prompt);
            if (res) {
                try {
                    const clean = res.replace(/```json/g, '').replace(/```/g, '').trim();
                    const newEvts = JSON.parse(clean);
                    newEvts.forEach(e => wxEvents.push(e));
                    persistData(); // SAVE NEW AI EVENTS
                    refreshPlanets(); 
                    alert(`âœ¨ è§‚æµ‹å®Œæˆï¼æ•è· ${newEvts.length} ä¸ªæ–°å˜é‡ã€‚`);
                } catch(e) { console.error(e); alert("ç¥è°•è§£æå¤±è´¥ (JSON Error)"); }
            }
            btn.classList.remove('loading'); btn.innerText = "ğŸ‘ è§‚æµ‹å¤©å¹•";
        }

        async function magicFill() {
            const txt = document.getElementById('ai-input').value;
            const prompt = `
            å°†ä»¥ä¸‹ç”¨æˆ·è¾“å…¥çš„è‡ªç„¶è¯­è¨€è½¬åŒ–ä¸ºæ—¥ç¨‹ JSONã€‚
            è¾“å…¥: "${txt}"
            å¦‚æœè¾“å…¥åŒ…å«ä¸–ç•Œè§‚ä¸­çš„äººç‰©(å¦‚è·¯å°å§, MJS, å°ç†Š)ï¼Œè¯·åœ¨æè¿°ä¸­åŠ å…¥ç›¸å…³æ¢—ã€‚
            è¿”å›æ ¼å¼: {"title":"", "daysAway":int, "desc":"", "subtasks":[""]}
            `;
            const btn = document.getElementById('magic-btn');
            btn.innerText = "è§£æä¸­...";
            const res = await callGemini(prompt);
            if (res) {
                try {
                    const clean = res.replace(/```json/g, '').replace(/```/g, '').trim();
                    const data = JSON.parse(clean);
                    document.getElementById('input-title').value = data.title;
                    document.getElementById('input-days').value = data.daysAway || 7;
                    document.getElementById('input-desc').value = data.desc;
                    if(data.subtasks) document.getElementById('input-subtasks').value = data.subtasks.join(', ');
                } catch(e) { console.error(e); }
            }
            btn.innerText = "âœ¨ è§£æç¥è°•";
        }

        setInterval(() => {
            const now = new Date();
            document.getElementById('clock-display').innerText = 
                now.getHours().toString().padStart(2, '0') + ":" + 
                now.getMinutes().toString().padStart(2, '0');
        }, 1000);

        const modal = document.getElementById('modal');
        function openModal() { modal.style.display = 'block'; }
        function closeModal() { modal.style.display = 'none'; }
        function saveEvent() {
            const t = document.getElementById('input-title').value;
            if(t) {
                const stStr = document.getElementById('input-subtasks').value;
                const stArr = stStr ? stStr.split(',').map(s => s.trim()).filter(s => s) : [];
                wxEvents.push({
                    title: t,
                    daysAway: parseInt(document.getElementById('input-days').value) || 1,
                    desc: document.getElementById('input-desc').value,
                    color: "#00f3ff",
                    subtasks: stArr
                });
                persistData(); // SAVE MANUAL EVENTS
                refreshPlanets(); 
                closeModal();
            }
        }
    </script>
</body>
</html>
